# Grns Attachments Schema & Migration Plan (Draft)

This doc is a follow-up to [Attachments Design](attachments.md) and focuses on concrete schema, migration sequencing, and implementation boundaries.

## Scope
- SQLite schema additions for attachments.
- Migration strategy compatible with `internal/store/migrations.go`.
- Interface and flow contracts for service/store/blob layers.
- MVP-first constraints (no object-store backend in this phase).

---

## Design constraints
1. Keep task query performance unchanged.
2. Keep managed blob bytes out of SQLite rows.
3. Enforce source-shape validity at DB level where practical.
4. Separate technical type (`media_type`) from workflow intent (`kind` + labels).
5. Keep migration additive and backward-compatible.
6. Allow orphan-blob recovery by GC after partial failures.

---

## Proposed migration (v5)

Append a new migration in `internal/store/migrations.go`:

- **Version:** `5` (next after current v4)
- **Description:** `attachments: add blobs, attachments, and attachment_labels tables with constraints and indexes`

### SQL (proposed)
```sql
CREATE TABLE IF NOT EXISTS blobs (
  id TEXT PRIMARY KEY,
  sha256 TEXT NOT NULL UNIQUE,
  size_bytes INTEGER NOT NULL CHECK(size_bytes >= 0),
  storage_backend TEXT NOT NULL,
  blob_key TEXT NOT NULL,
  created_at TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS attachments (
  id TEXT PRIMARY KEY,
  task_id TEXT NOT NULL,
  kind TEXT NOT NULL,
  source_type TEXT NOT NULL,
  title TEXT,
  filename TEXT,
  media_type TEXT,
  media_type_source TEXT NOT NULL DEFAULT 'unknown',

  -- source payload (exactly one source pattern enforced below)
  blob_id TEXT,
  external_url TEXT,
  repo_path TEXT,

  -- constrained metadata extension (JSON text)
  meta_json TEXT,

  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  expires_at TEXT,

  FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
  FOREIGN KEY (blob_id) REFERENCES blobs(id) ON DELETE RESTRICT,

  CHECK (kind IN ('spec', 'diagram', 'artifact', 'diagnostic', 'archive', 'other')),
  CHECK (source_type IN ('managed_blob', 'external_url', 'repo_path')),
  CHECK (media_type_source IN ('sniffed', 'declared', 'inferred', 'unknown')),

  CHECK (
    (source_type = 'managed_blob' AND blob_id IS NOT NULL AND external_url IS NULL AND repo_path IS NULL) OR
    (source_type = 'external_url' AND blob_id IS NULL AND external_url IS NOT NULL AND repo_path IS NULL) OR
    (source_type = 'repo_path'    AND blob_id IS NULL AND external_url IS NULL AND repo_path IS NOT NULL)
  ),

  CHECK (expires_at IS NULL OR expires_at >= created_at)
);

CREATE TABLE IF NOT EXISTS attachment_labels (
  attachment_id TEXT NOT NULL,
  label TEXT NOT NULL,
  PRIMARY KEY (attachment_id, label),
  FOREIGN KEY (attachment_id) REFERENCES attachments(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_attachments_task_created
  ON attachments(task_id, created_at);

CREATE INDEX IF NOT EXISTS idx_attachments_kind
  ON attachments(kind);

CREATE INDEX IF NOT EXISTS idx_attachments_media_type
  ON attachments(media_type);

CREATE INDEX IF NOT EXISTS idx_attachments_source_type
  ON attachments(source_type);

CREATE INDEX IF NOT EXISTS idx_attachments_blob_id
  ON attachments(blob_id);

CREATE INDEX IF NOT EXISTS idx_attachments_expires_at
  ON attachments(expires_at);

CREATE INDEX IF NOT EXISTS idx_attachment_labels_label
  ON attachment_labels(label);
```

### Notes on constraints
- DB constraints protect against malformed mixed-source rows.
- `kind` stays intentionally coarse; labels carry project-specific workflow tags.
- `media_type_source` preserves provenance of MIME classification decisions.
- `ON DELETE RESTRICT` for `blob_id` prevents accidental blob metadata deletion while referenced.
- GC should delete unreferenced blobs explicitly.

---

## IDs and formats

### Attachment IDs
- Prefix: `at-`
- Suggested pattern: short lowercase base36 (`at-xxxxxxxx`)
- Generated by service layer.

### Blob IDs
- Prefix: `bl-`
- Suggested pattern: short lowercase base36 (`bl-xxxxxxxx`)

### SHA-256
- Lowercase hex digest, 64 chars.
- Service validation should enforce this shape before insert.

### Concrete model structs (proposed)

`internal/models/attachment.go`:

```go
package models

import "time"

type AttachmentKind string

const (
	AttachmentKindSpec       AttachmentKind = "spec"
	AttachmentKindDiagram    AttachmentKind = "diagram"
	AttachmentKindArtifact   AttachmentKind = "artifact"
	AttachmentKindDiagnostic AttachmentKind = "diagnostic"
	AttachmentKindArchive    AttachmentKind = "archive"
	AttachmentKindOther      AttachmentKind = "other"
)

type AttachmentSourceType string

const (
	AttachmentSourceManagedBlob AttachmentSourceType = "managed_blob"
	AttachmentSourceExternalURL AttachmentSourceType = "external_url"
	AttachmentSourceRepoPath    AttachmentSourceType = "repo_path"
)

type AttachmentMediaTypeSource string

const (
	MediaTypeSourceSniffed  AttachmentMediaTypeSource = "sniffed"
	MediaTypeSourceDeclared AttachmentMediaTypeSource = "declared"
	MediaTypeSourceInferred AttachmentMediaTypeSource = "inferred"
	MediaTypeSourceUnknown  AttachmentMediaTypeSource = "unknown"
)

type Attachment struct {
	ID              string                    `json:"id"`
	TaskID          string                    `json:"task_id"`
	Kind            string                    `json:"kind"`
	SourceType      string                    `json:"source_type"`
	Title           string                    `json:"title,omitempty"`
	Filename        string                    `json:"filename,omitempty"`
	MediaType       string                    `json:"media_type,omitempty"`
	MediaTypeSource string                    `json:"media_type_source,omitempty"`
	BlobID          string                    `json:"blob_id,omitempty"`
	ExternalURL     string                    `json:"external_url,omitempty"`
	RepoPath        string                    `json:"repo_path,omitempty"`
	Meta            map[string]any            `json:"meta,omitempty"`
	Labels          []string                  `json:"labels,omitempty"`
	CreatedAt       time.Time                 `json:"created_at"`
	UpdatedAt       time.Time                 `json:"updated_at"`
	ExpiresAt       *time.Time                `json:"expires_at,omitempty"`
}
```

`internal/models/blob.go`:

```go
package models

import "time"

type Blob struct {
	ID             string    `json:"id"`
	SHA256         string    `json:"sha256"`
	SizeBytes      int64     `json:"size_bytes"`
	StorageBackend string    `json:"storage_backend"`
	BlobKey        string    `json:"blob_key"`
	CreatedAt      time.Time `json:"created_at"`
}
```

Notes:
- Keep `Kind`, `SourceType`, `MediaTypeSource` as string-backed enums to align with existing model style.
- `Labels` is API-facing convenience; persist in `attachment_labels` join table.

---

## Storage key conventions

### `storage_backend`
MVP fixed value:
- `local_cas`

### `blob_key`
Backend-specific locator. For local CAS use key form (not absolute path):
- `sha256/ab/cd/<full_sha256>`

Rationale:
- Avoid embedding machine-specific absolute paths in DB.
- Backend portability for future remote stores.

### MIME handling policy (MVP)
- Managed uploads: detect MIME from bytes and store normalized lowercase `media_type`.
- Declared `media_type` from clients is optional and may be rejected when mismatched with detected type.
- Link/path attachments may provide `media_type`; otherwise keep null or inferred best-effort.
- Track provenance via `media_type_source` (`sniffed`, `declared`, `inferred`, `unknown`).

---

### Concrete `migrations.go` snippet (copy/adapt)

```go
{
	Version:     5,
	Description: "attachments: add blobs, attachments, and attachment_labels tables with constraints and indexes",
	SQL: `
CREATE TABLE IF NOT EXISTS blobs (
  id TEXT PRIMARY KEY,
  sha256 TEXT NOT NULL UNIQUE,
  size_bytes INTEGER NOT NULL CHECK(size_bytes >= 0),
  storage_backend TEXT NOT NULL,
  blob_key TEXT NOT NULL,
  created_at TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS attachments (
  id TEXT PRIMARY KEY,
  task_id TEXT NOT NULL,
  kind TEXT NOT NULL,
  source_type TEXT NOT NULL,
  title TEXT,
  filename TEXT,
  media_type TEXT,
  media_type_source TEXT NOT NULL DEFAULT 'unknown',
  blob_id TEXT,
  external_url TEXT,
  repo_path TEXT,
  meta_json TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  expires_at TEXT,
  FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
  FOREIGN KEY (blob_id) REFERENCES blobs(id) ON DELETE RESTRICT,
  CHECK (kind IN ('spec', 'diagram', 'artifact', 'diagnostic', 'archive', 'other')),
  CHECK (source_type IN ('managed_blob', 'external_url', 'repo_path')),
  CHECK (media_type_source IN ('sniffed', 'declared', 'inferred', 'unknown')),
  CHECK (
    (source_type = 'managed_blob' AND blob_id IS NOT NULL AND external_url IS NULL AND repo_path IS NULL) OR
    (source_type = 'external_url' AND blob_id IS NULL AND external_url IS NOT NULL AND repo_path IS NULL) OR
    (source_type = 'repo_path'    AND blob_id IS NULL AND external_url IS NULL AND repo_path IS NOT NULL)
  ),
  CHECK (expires_at IS NULL OR expires_at >= created_at)
);

CREATE TABLE IF NOT EXISTS attachment_labels (
  attachment_id TEXT NOT NULL,
  label TEXT NOT NULL,
  PRIMARY KEY (attachment_id, label),
  FOREIGN KEY (attachment_id) REFERENCES attachments(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_attachments_task_created ON attachments(task_id, created_at);
CREATE INDEX IF NOT EXISTS idx_attachments_kind ON attachments(kind);
CREATE INDEX IF NOT EXISTS idx_attachments_media_type ON attachments(media_type);
CREATE INDEX IF NOT EXISTS idx_attachments_source_type ON attachments(source_type);
CREATE INDEX IF NOT EXISTS idx_attachments_blob_id ON attachments(blob_id);
CREATE INDEX IF NOT EXISTS idx_attachments_expires_at ON attachments(expires_at);
CREATE INDEX IF NOT EXISTS idx_attachment_labels_label ON attachment_labels(label);
`,
},
```

## Service and interface plan

### New interfaces
Keep `TaskStore` focused on task domain. Add:

```go
// internal/store/attachments_interface.go (proposed)
type AttachmentStore interface {
    CreateAttachment(ctx context.Context, a *models.Attachment) error
    GetAttachment(ctx context.Context, id string) (*models.Attachment, error)
    ListAttachmentsByTask(ctx context.Context, taskID string) ([]models.Attachment, error)
    DeleteAttachment(ctx context.Context, id string) error

    ReplaceAttachmentLabels(ctx context.Context, attachmentID string, labels []string) error
    ListAttachmentLabels(ctx context.Context, attachmentID string) ([]string, error)

    UpsertBlob(ctx context.Context, b *models.Blob) (*models.Blob, error)
    GetBlob(ctx context.Context, id string) (*models.Blob, error)
    GetBlobBySHA256(ctx context.Context, sha string) (*models.Blob, error)
    ListUnreferencedBlobs(ctx context.Context, limit int) ([]models.Blob, error)
    DeleteBlob(ctx context.Context, id string) error
}
```

```go
// internal/blobstore/interface.go (proposed)
type BlobStore interface {
    Put(ctx context.Context, r io.Reader) (BlobPutResult, error)
    Open(ctx context.Context, key string) (io.ReadCloser, error)
    Delete(ctx context.Context, key string) error
}

type BlobPutResult struct {
    SHA256    string
    SizeBytes int64
    BlobKey   string
}
```

### Service
Add `AttachmentService` in `internal/server`:
- `CreateManagedAttachment(...)`
- `CreateLinkAttachment(...)`
- `ListTaskAttachments(...)`
- `GetAttachment(...)`
- `StreamAttachmentContent(...)`
- `DeleteAttachment(...)`
- `GCBlobs(...)`

All validation and business rules should live here (consistent with project rules), including MIME normalization/mismatch handling and attachment label normalization.

---

## API contract details (MVP)

### Create managed attachment
`POST /v1/tasks/{id}/attachments` (multipart)
- fields: `kind` (required), `title` (optional), `expires_at` (optional), `media_type` (optional), `labels[]` (optional), `content` (required file)

### Create link attachment
`POST /v1/tasks/{id}/attachments/link` (JSON)
- body supports one of `external_url` or `repo_path`
- optional fields: `media_type`, `labels[]`

### List/show/get/delete
- `GET /v1/tasks/{id}/attachments`
- `GET /v1/attachments/{attachment_id}`
- `GET /v1/attachments/{attachment_id}/content` (managed only)
- `DELETE /v1/attachments/{attachment_id}`

List/show responses should include `media_type`, `media_type_source`, and `labels[]`.

Error mapping:
- validation -> `badRequest`
- missing task/attachment/blob metadata -> `notFound`
- duplicate violations -> `conflict`

---

## Failure and consistency model

### Upload path
Because file IO and SQL transaction cannot be a single atomic unit:
1. BlobStore writes content and returns digest/key.
2. Service upserts blob metadata + inserts attachment metadata.
3. If metadata insert fails after blob write, blob becomes orphan-candidate.
4. GC later removes unreferenced blobs.

This is acceptable for MVP and keeps implementation simple/reliable.

### Delete path
1. Delete attachment metadata row.
2. Blob row remains until GC confirms no references.
3. GC removes blob bytes and blob row.

---

## GC algorithm (MVP)

Command: `grns admin gc-blobs --dry-run|--apply`

Per batch:
1. Query unreferenced blobs (left join attachments where `attachments.blob_id IS NULL`).
2. For each candidate:
   - try delete from BlobStore by `blob_key`
   - delete `blobs` row
3. Continue until batch empty.

Output JSON fields:
- `candidate_count`
- `deleted_count`
- `failed_count`
- `reclaimed_bytes`
- `dry_run`

---

## Backward compatibility
- Existing task model remains unchanged.
- `spec_id` remains supported.
- No automatic `spec_id` backfill into attachments in migration v5.
  - Optional future command: `grns admin backfill-spec-attachments`.

---

## Config keys (proposed)
- `attachments.max_upload_bytes` (default `104857600`)
- `attachments.allowed_media_types` (default empty = allow all)
- `attachments.reject_media_type_mismatch` (default `true`)
- `attachments.gc_batch_size` (default `500`)
- `attachments.gc_interval` (default `24h`)
- `attachments.enable_archive_inspection` (default `false`)

If archive inspection is enabled later:
- `attachments.archive.max_entries`
- `attachments.archive.max_total_unpacked_bytes`
- `attachments.archive.max_path_length`

---

## Test plan

### Store tests
- Create/list/get/delete attachments.
- Constraint violations (bad source shape, invalid kind/source_type/media_type_source).
- Label persistence via `attachment_labels`.
- Blob upsert by SHA-256 uniqueness.
- Unreferenced blob query correctness.

### Service tests
- Input validation and normalization.
- MIME detection/normalization and mismatch behavior.
- Label normalization/dedupe behavior.
- Error type mapping (`badRequest`, `notFound`, `conflict`).
- Partial failure behavior (orphan candidate path).

### Integration (BATS)
- attach add -> attach list -> attach get -> attach rm
- add-link (url + repo-path)
- media_type and label round-trip in JSON responses
- gc-blobs dry-run/apply

---

## Open implementation choices
1. Should `repo_path` be validated as workspace-relative only?
2. Should duplicate link attachments (same task + same URL/path) be deduped?
3. Should attachment IDs use deterministic or random generation?
4. Should GC run only via command in MVP, or also as periodic daemon task?
5. Should `reject_media_type_mismatch` be globally strict, or allow per-command override for trusted workflows?

---

## Recommendation
Use migration v5 above as the concrete MVP baseline, then implement `AttachmentService` + `AttachmentStore` + local CAS `BlobStore` with explicit GC semantics, adopting the 3-axis classification model (`kind`, `media_type`, `labels`).
