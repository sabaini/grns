# Grns Attachments Schema & Migration Plan (Draft)

This doc is a follow-up to [Attachments Design](attachments.md) and focuses on concrete schema, migration sequencing, and implementation boundaries.

## Scope
- SQLite schema additions for attachments.
- Migration strategy compatible with `internal/store/migrations.go`.
- Interface and flow contracts for service/store/blob layers.
- MVP-first constraints (no object-store backend in this phase).

---

## Design constraints
1. Keep task query performance unchanged.
2. Keep managed blob bytes out of SQLite rows.
3. Enforce source-shape validity at DB level where practical.
4. Keep migration additive and backward-compatible.
5. Allow orphan-blob recovery by GC after partial failures.

---

## Proposed migration (v4)

Append a new migration in `internal/store/migrations.go`:

- **Version:** `4`
- **Description:** `attachments: add blobs and attachments tables with constraints and indexes`

### SQL (proposed)
```sql
CREATE TABLE IF NOT EXISTS blobs (
  id TEXT PRIMARY KEY,
  sha256 TEXT NOT NULL UNIQUE,
  size_bytes INTEGER NOT NULL CHECK(size_bytes >= 0),
  storage_backend TEXT NOT NULL,
  blob_key TEXT NOT NULL,
  created_at TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS attachments (
  id TEXT PRIMARY KEY,
  task_id TEXT NOT NULL,
  kind TEXT NOT NULL,
  source_type TEXT NOT NULL,
  title TEXT,
  filename TEXT,
  media_type TEXT,

  -- source payload (exactly one source pattern enforced below)
  blob_id TEXT,
  external_url TEXT,
  repo_path TEXT,

  -- constrained metadata extension (JSON text)
  meta_json TEXT,

  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  expires_at TEXT,

  FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
  FOREIGN KEY (blob_id) REFERENCES blobs(id) ON DELETE RESTRICT,

  CHECK (kind IN ('spec', 'diagram', 'artifact', 'diagnostic', 'archive', 'other')),
  CHECK (source_type IN ('managed_blob', 'external_url', 'repo_path')),

  CHECK (
    (source_type = 'managed_blob' AND blob_id IS NOT NULL AND external_url IS NULL AND repo_path IS NULL) OR
    (source_type = 'external_url' AND blob_id IS NULL AND external_url IS NOT NULL AND repo_path IS NULL) OR
    (source_type = 'repo_path'    AND blob_id IS NULL AND external_url IS NULL AND repo_path IS NOT NULL)
  ),

  CHECK (expires_at IS NULL OR expires_at >= created_at)
);

CREATE INDEX IF NOT EXISTS idx_attachments_task_created
  ON attachments(task_id, created_at);

CREATE INDEX IF NOT EXISTS idx_attachments_kind
  ON attachments(kind);

CREATE INDEX IF NOT EXISTS idx_attachments_source_type
  ON attachments(source_type);

CREATE INDEX IF NOT EXISTS idx_attachments_blob_id
  ON attachments(blob_id);

CREATE INDEX IF NOT EXISTS idx_attachments_expires_at
  ON attachments(expires_at);
```

### Notes on constraints
- DB constraints protect against malformed mixed-source rows.
- `ON DELETE RESTRICT` for `blob_id` prevents accidental blob metadata deletion while referenced.
- GC should delete unreferenced blobs explicitly.

---

## IDs and formats

### Attachment IDs
- Prefix: `at-`
- Suggested pattern: short lowercase base36 (`at-xxxxxxxx`)
- Generated by service layer.

### Blob IDs
- Prefix: `bl-`
- Suggested pattern: short lowercase base36 (`bl-xxxxxxxx`)

### SHA-256
- Lowercase hex digest, 64 chars.
- Service validation should enforce this shape before insert.

---

## Storage key conventions

### `storage_backend`
MVP fixed value:
- `local_cas`

### `blob_key`
Backend-specific locator. For local CAS use key form (not absolute path):
- `sha256/ab/cd/<full_sha256>`

Rationale:
- Avoid embedding machine-specific absolute paths in DB.
- Backend portability for future remote stores.

---

## Service and interface plan

### New interfaces
Keep `TaskStore` focused on task domain. Add:

```go
// internal/store/attachments_interface.go (proposed)
type AttachmentStore interface {
    CreateAttachment(ctx context.Context, a *models.Attachment) error
    GetAttachment(ctx context.Context, id string) (*models.Attachment, error)
    ListAttachmentsByTask(ctx context.Context, taskID string) ([]models.Attachment, error)
    DeleteAttachment(ctx context.Context, id string) error

    UpsertBlob(ctx context.Context, b *models.Blob) (*models.Blob, error)
    GetBlob(ctx context.Context, id string) (*models.Blob, error)
    GetBlobBySHA256(ctx context.Context, sha string) (*models.Blob, error)
    ListUnreferencedBlobs(ctx context.Context, limit int) ([]models.Blob, error)
    DeleteBlob(ctx context.Context, id string) error
}
```

```go
// internal/blobstore/interface.go (proposed)
type BlobStore interface {
    Put(ctx context.Context, r io.Reader) (BlobPutResult, error)
    Open(ctx context.Context, key string) (io.ReadCloser, error)
    Delete(ctx context.Context, key string) error
}

type BlobPutResult struct {
    SHA256    string
    SizeBytes int64
    BlobKey   string
}
```

### Service
Add `AttachmentService` in `internal/server`:
- `CreateManagedAttachment(...)`
- `CreateLinkAttachment(...)`
- `ListTaskAttachments(...)`
- `GetAttachment(...)`
- `StreamAttachmentContent(...)`
- `DeleteAttachment(...)`
- `GCBlobs(...)`

All validation and business rules should live here (consistent with project rules).

---

## API contract details (MVP)

### Create managed attachment
`POST /v1/tasks/{id}/attachments` (multipart)
- fields: `kind` (required), `title` (optional), `expires_at` (optional), `content` (required file)

### Create link attachment
`POST /v1/tasks/{id}/attachments/link` (JSON)
- body supports one of `external_url` or `repo_path`

### List/show/get/delete
- `GET /v1/tasks/{id}/attachments`
- `GET /v1/attachments/{attachment_id}`
- `GET /v1/attachments/{attachment_id}/content` (managed only)
- `DELETE /v1/attachments/{attachment_id}`

Error mapping:
- validation -> `badRequest`
- missing task/attachment/blob metadata -> `notFound`
- duplicate violations -> `conflict`

---

## Failure and consistency model

### Upload path
Because file IO and SQL transaction cannot be a single atomic unit:
1. BlobStore writes content and returns digest/key.
2. Service upserts blob metadata + inserts attachment metadata.
3. If metadata insert fails after blob write, blob becomes orphan-candidate.
4. GC later removes unreferenced blobs.

This is acceptable for MVP and keeps implementation simple/reliable.

### Delete path
1. Delete attachment metadata row.
2. Blob row remains until GC confirms no references.
3. GC removes blob bytes and blob row.

---

## GC algorithm (MVP)

Command: `grns admin gc-blobs --dry-run|--apply`

Per batch:
1. Query unreferenced blobs (left join attachments where `attachments.blob_id IS NULL`).
2. For each candidate:
   - try delete from BlobStore by `blob_key`
   - delete `blobs` row
3. Continue until batch empty.

Output JSON fields:
- `candidate_count`
- `deleted_count`
- `failed_count`
- `reclaimed_bytes`
- `dry_run`

---

## Backward compatibility
- Existing task model remains unchanged.
- `spec_id` remains supported.
- No automatic `spec_id` backfill into attachments in migration v4.
  - Optional future command: `grns admin backfill-spec-attachments`.

---

## Config keys (proposed)
- `attachments.max_upload_bytes` (default `104857600`)
- `attachments.gc_batch_size` (default `500`)
- `attachments.gc_interval` (default `24h`)
- `attachments.enable_archive_inspection` (default `false`)

If archive inspection is enabled later:
- `attachments.archive.max_entries`
- `attachments.archive.max_total_unpacked_bytes`
- `attachments.archive.max_path_length`

---

## Test plan

### Store tests
- Create/list/get/delete attachments.
- Constraint violations (bad source shape, invalid kind/source_type).
- Blob upsert by SHA-256 uniqueness.
- Unreferenced blob query correctness.

### Service tests
- Input validation and normalization.
- Error type mapping (`badRequest`, `notFound`, `conflict`).
- Partial failure behavior (orphan candidate path).

### Integration (BATS)
- attach add -> attach list -> attach get -> attach rm
- add-link (url + repo-path)
- gc-blobs dry-run/apply

---

## Open implementation choices
1. Should `repo_path` be validated as workspace-relative only?
2. Should duplicate link attachments (same task + same URL/path) be deduped?
3. Should attachment IDs use deterministic or random generation?
4. Should GC run only via command in MVP, or also as periodic daemon task?

---

## Recommendation
Use migration v4 above as the concrete MVP baseline, then implement `AttachmentService` + `AttachmentStore` + local CAS `BlobStore` with explicit GC semantics.
